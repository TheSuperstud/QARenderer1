//
// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.11 
// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
// Any modifications to this file will be lost upon recompilation of the source schema. 
// Generated on: 2014.12.12 at 03:51:03 AM CET 
//


package org.imsglobal.xsd.imsqti_v2p1;

import java.util.ArrayList;
import java.util.List;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAnyElement;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlSchemaType;
import javax.xml.bind.annotation.XmlType;
import org.w3c.dom.Element;


/**
 * <p>Java class for contentProfile.Type complex type.
 * 
 * <p>The following schema fragment specifies the expected content contained within this class.
 * 
 * <pre>
 * &lt;complexType name="contentProfile.Type"&gt;
 *   &lt;complexContent&gt;
 *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType"&gt;
 *       &lt;group ref="{http://www.imsglobal.org/xsd/imsqti_v2p1}contentProfile.ContentGroup"/&gt;
 *     &lt;/restriction&gt;
 *   &lt;/complexContent&gt;
 * &lt;/complexType&gt;
 * </pre>
 * 
 * 
 */
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "contentProfile.Type", propOrder = {
    "composite",
    "adaptive",
    "timeDependent",
    "templates",
    "textElements",
    "listElements",
    "objectElements",
    "objectTypes",
    "presentationElements",
    "tableElements",
    "imageElement",
    "imageTypes",
    "hypertextElement",
    "mathElement",
    "mathVariable",
    "feedbackIntegrated",
    "feedbackModal",
    "rubric",
    "printedVariables",
    "interactionTypes",
    "responseRules",
    "rpTemplates",
    "rounding",
    "regexp",
    "metadataProfile",
    "anies"
})
@XmlRootElement(name = "contentProfile")
public class ContentProfile {

    protected boolean composite;
    protected boolean adaptive;
    protected boolean timeDependent;
    protected boolean templates;
    protected boolean textElements;
    protected boolean listElements;
    protected boolean objectElements;
    @XmlElement(name = "objectType")
    protected List<String> objectTypes;
    protected boolean presentationElements;
    protected boolean tableElements;
    protected boolean imageElement;
    @XmlElement(name = "imageType")
    protected List<String> imageTypes;
    protected boolean hypertextElement;
    protected boolean mathElement;
    protected boolean mathVariable;
    protected boolean feedbackIntegrated;
    protected boolean feedbackModal;
    protected boolean rubric;
    protected boolean printedVariables;
    @XmlElement(name = "interactionType")
    @XmlSchemaType(name = "NMTOKEN")
    protected List<InteractionTypeType> interactionTypes;
    protected boolean responseRules;
    @XmlElement(name = "rpTemplate")
    @XmlSchemaType(name = "anyURI")
    protected List<String> rpTemplates;
    protected boolean rounding;
    protected boolean regexp;
    @XmlElement(required = true)
    protected MetadataProfile metadataProfile;
    @XmlAnyElement
    protected List<Element> anies;

    /**
     * Gets the value of the composite property.
     * 
     */
    public boolean isComposite() {
        return composite;
    }

    /**
     * Sets the value of the composite property.
     * 
     */
    public void setComposite(boolean value) {
        this.composite = value;
    }

    /**
     * Gets the value of the adaptive property.
     * 
     */
    public boolean isAdaptive() {
        return adaptive;
    }

    /**
     * Sets the value of the adaptive property.
     * 
     */
    public void setAdaptive(boolean value) {
        this.adaptive = value;
    }

    /**
     * Gets the value of the timeDependent property.
     * 
     */
    public boolean isTimeDependent() {
        return timeDependent;
    }

    /**
     * Sets the value of the timeDependent property.
     * 
     */
    public void setTimeDependent(boolean value) {
        this.timeDependent = value;
    }

    /**
     * Gets the value of the templates property.
     * 
     */
    public boolean isTemplates() {
        return templates;
    }

    /**
     * Sets the value of the templates property.
     * 
     */
    public void setTemplates(boolean value) {
        this.templates = value;
    }

    /**
     * Gets the value of the textElements property.
     * 
     */
    public boolean isTextElements() {
        return textElements;
    }

    /**
     * Sets the value of the textElements property.
     * 
     */
    public void setTextElements(boolean value) {
        this.textElements = value;
    }

    /**
     * Gets the value of the listElements property.
     * 
     */
    public boolean isListElements() {
        return listElements;
    }

    /**
     * Sets the value of the listElements property.
     * 
     */
    public void setListElements(boolean value) {
        this.listElements = value;
    }

    /**
     * Gets the value of the objectElements property.
     * 
     */
    public boolean isObjectElements() {
        return objectElements;
    }

    /**
     * Sets the value of the objectElements property.
     * 
     */
    public void setObjectElements(boolean value) {
        this.objectElements = value;
    }

    /**
     * Gets the value of the objectTypes property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the objectTypes property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getObjectTypes().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link String }
     * 
     * 
     */
    public List<String> getObjectTypes() {
        if (objectTypes == null) {
            objectTypes = new ArrayList<String>();
        }
        return this.objectTypes;
    }

    /**
     * Gets the value of the presentationElements property.
     * 
     */
    public boolean isPresentationElements() {
        return presentationElements;
    }

    /**
     * Sets the value of the presentationElements property.
     * 
     */
    public void setPresentationElements(boolean value) {
        this.presentationElements = value;
    }

    /**
     * Gets the value of the tableElements property.
     * 
     */
    public boolean isTableElements() {
        return tableElements;
    }

    /**
     * Sets the value of the tableElements property.
     * 
     */
    public void setTableElements(boolean value) {
        this.tableElements = value;
    }

    /**
     * Gets the value of the imageElement property.
     * 
     */
    public boolean isImageElement() {
        return imageElement;
    }

    /**
     * Sets the value of the imageElement property.
     * 
     */
    public void setImageElement(boolean value) {
        this.imageElement = value;
    }

    /**
     * Gets the value of the imageTypes property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the imageTypes property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getImageTypes().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link String }
     * 
     * 
     */
    public List<String> getImageTypes() {
        if (imageTypes == null) {
            imageTypes = new ArrayList<String>();
        }
        return this.imageTypes;
    }

    /**
     * Gets the value of the hypertextElement property.
     * 
     */
    public boolean isHypertextElement() {
        return hypertextElement;
    }

    /**
     * Sets the value of the hypertextElement property.
     * 
     */
    public void setHypertextElement(boolean value) {
        this.hypertextElement = value;
    }

    /**
     * Gets the value of the mathElement property.
     * 
     */
    public boolean isMathElement() {
        return mathElement;
    }

    /**
     * Sets the value of the mathElement property.
     * 
     */
    public void setMathElement(boolean value) {
        this.mathElement = value;
    }

    /**
     * Gets the value of the mathVariable property.
     * 
     */
    public boolean isMathVariable() {
        return mathVariable;
    }

    /**
     * Sets the value of the mathVariable property.
     * 
     */
    public void setMathVariable(boolean value) {
        this.mathVariable = value;
    }

    /**
     * Gets the value of the feedbackIntegrated property.
     * 
     */
    public boolean isFeedbackIntegrated() {
        return feedbackIntegrated;
    }

    /**
     * Sets the value of the feedbackIntegrated property.
     * 
     */
    public void setFeedbackIntegrated(boolean value) {
        this.feedbackIntegrated = value;
    }

    /**
     * Gets the value of the feedbackModal property.
     * 
     */
    public boolean isFeedbackModal() {
        return feedbackModal;
    }

    /**
     * Sets the value of the feedbackModal property.
     * 
     */
    public void setFeedbackModal(boolean value) {
        this.feedbackModal = value;
    }

    /**
     * Gets the value of the rubric property.
     * 
     */
    public boolean isRubric() {
        return rubric;
    }

    /**
     * Sets the value of the rubric property.
     * 
     */
    public void setRubric(boolean value) {
        this.rubric = value;
    }

    /**
     * Gets the value of the printedVariables property.
     * 
     */
    public boolean isPrintedVariables() {
        return printedVariables;
    }

    /**
     * Sets the value of the printedVariables property.
     * 
     */
    public void setPrintedVariables(boolean value) {
        this.printedVariables = value;
    }

    /**
     * Gets the value of the interactionTypes property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the interactionTypes property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getInteractionTypes().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link InteractionTypeType }
     * 
     * 
     */
    public List<InteractionTypeType> getInteractionTypes() {
        if (interactionTypes == null) {
            interactionTypes = new ArrayList<InteractionTypeType>();
        }
        return this.interactionTypes;
    }

    /**
     * Gets the value of the responseRules property.
     * 
     */
    public boolean isResponseRules() {
        return responseRules;
    }

    /**
     * Sets the value of the responseRules property.
     * 
     */
    public void setResponseRules(boolean value) {
        this.responseRules = value;
    }

    /**
     * Gets the value of the rpTemplates property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the rpTemplates property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getRpTemplates().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link String }
     * 
     * 
     */
    public List<String> getRpTemplates() {
        if (rpTemplates == null) {
            rpTemplates = new ArrayList<String>();
        }
        return this.rpTemplates;
    }

    /**
     * Gets the value of the rounding property.
     * 
     */
    public boolean isRounding() {
        return rounding;
    }

    /**
     * Sets the value of the rounding property.
     * 
     */
    public void setRounding(boolean value) {
        this.rounding = value;
    }

    /**
     * Gets the value of the regexp property.
     * 
     */
    public boolean isRegexp() {
        return regexp;
    }

    /**
     * Sets the value of the regexp property.
     * 
     */
    public void setRegexp(boolean value) {
        this.regexp = value;
    }

    /**
     * Gets the value of the metadataProfile property.
     * 
     * @return
     *     possible object is
     *     {@link MetadataProfile }
     *     
     */
    public MetadataProfile getMetadataProfile() {
        return metadataProfile;
    }

    /**
     * Sets the value of the metadataProfile property.
     * 
     * @param value
     *     allowed object is
     *     {@link MetadataProfile }
     *     
     */
    public void setMetadataProfile(MetadataProfile value) {
        this.metadataProfile = value;
    }

    /**
     * Gets the value of the anies property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the anies property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getAnies().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link Element }
     * 
     * 
     */
    public List<Element> getAnies() {
        if (anies == null) {
            anies = new ArrayList<Element>();
        }
        return this.anies;
    }

}
